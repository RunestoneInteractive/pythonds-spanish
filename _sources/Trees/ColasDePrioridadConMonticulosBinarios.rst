..  Copyright (C)  Brad Miller, David Ranum
    This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/.


Colas de prioridad con montículos binarios
------------------------------------------

En las secciones anteriores usted aprendió sobre la estructura de datos LIFO denominada cola. Una variante importante de una cola se denomina una **cola de prioridad**. Una cola de prioridad actúa como una cola puesto que se quita un ítem eliminándolo del frente. Sin embargo, en una cola de prioridad el orden lógico de los ítems dentro de una cola se determina por su prioridad. Los ítems de prioridad más alta se encuentran en el frente de la cola y los elementos de menor prioridad se encuentran en el final. Por lo tanto, cuando se agrega un ítem en una cola de prioridad, el nuevo ítem puede moverse por todo el camino hasta el frente. Veremos que la cola de prioridad es una estructura de datos útil para algunos de los algoritmos de grafos que estudiaremos en el capítulo siguiente.

.. In earlier sections you learned about the first-in first-out data structure called a queue. One important variation of a queue is called a **priority queue**. A priority queue acts like a queue in that you dequeue an item by removing it from the front. However, in a priority queue the logical order of items inside a queue is determined by their priority. The highest priority items are at the front of the queue and the lowest priority items are at the back. Thus when you enqueue an item on a priority queue, the new item may move all the way to the front. We will see that the priority queue is a useful data structure for some of the graph algorithms we will study in the next chapter.

Usted probablemente puede pensar en un par de maneras fáciles de implementar una cola de prioridad usando funciones de ordenamiento y listas. Sin embargo, insertar en una lista es :math:`O(n)` y ordenar una lista es :math:`O(n \log{n})`. Podemos hacerlo mejor. La manera clásica de implementar una cola de prioridad es usar una estructura de datos llamada **montículo binario**. Un montículo binario nos permitirá tanto agregar como hacer avanzar ítems en :math:`O(\log{n})`.

.. You can probably think of a couple of easy ways to implement a priority queue using sorting functions and lists. However, inserting into a list is :math:`O(n)` and sorting a list is :math:`O(n \log{n})`. We can do better. The classic way to implement a priority queue is using a data structure called a **binary heap**. A binary heap will allow us both enqueue and dequeue items in :math:`O(\log{n})`.

El montículo binario es interesante de estudiar porque cuando diagramamos el montículo se parece mucho a un árbol, pero cuando lo implementamos usamos únicamente una sola lista como representación interna. El montículo binario tiene dos variantes comunes: el **montículo mín**, en el que la clave más pequeña está siempre en el frente, y el **montículo máx**, en el que el valor clave más grande siempre está en el frente. En esta sección implementaremos el montículo mín. Dejamos como ejercicio la implementación del montículo máx.

.. The binary heap is interesting to study because when we diagram the heap it looks a lot like a tree, but when we implement it we use only a single list as an internal representation. The binary heap has two common variations: the **min heap**, in which the smallest key is always at the front, and the **max heap**, in which the largest key value is always at the front. In this section we will implement the min heap. We leave a max heap implementation as an exercise.
